import { Project, VariableDeclarationKind } from "ts-morph";
import { existsSync, mkdirSync } from "node:fs";
import { dirname } from "node:path";
import { logger } from "./logger";
import prettier from "prettier";
import { generateFieldCode } from "../../lib/codeGenerator";

export { generateFullCode } from "../../lib/codeGenerator";

export interface FieldConfig {
  name: string;
  type: "string" | "number" | "boolean" | "date" | "array" | "object";
  validation?: string[];
  metadata?: Record<string, unknown>;
  optional?: boolean;
}

export interface SchemaConfig {
  name: string;
  fields: FieldConfig[];
  description?: string;
}

export class CodeGenerator {
  private project: Project;

  constructor() {
    this.project = new Project({
      tsConfigFilePath: "tsconfig.json",
      skipAddingFilesFromTsConfig: true,
    });
  }

  /**
   * Format code with prettier
   */
  private async formatCode(code: string): Promise<string> {
    try {
      return await prettier.format(code, {
        parser: "typescript",
        semi: true,
        singleQuote: false,
        tabWidth: 2,
        trailingComma: "es5",
      });
    } catch (error) {
      logger.warn("Failed to format code with prettier:", error);
      return code;
    }
  }

  /**
   * Generate a complete schema file
   */
  async generateSchema(
    config: SchemaConfig,
    outputPath: string
  ): Promise<void> {
    logger.info(`ðŸ”§ Generating schema: ${config.name}`);

    // Ensure output directory exists
    const dir = dirname(outputPath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    const sourceFile = this.project.createSourceFile(outputPath, "", {
      overwrite: true,
    });

    // Add imports with proper aliases
    sourceFile.addImportDeclaration({
      moduleSpecifier: "zod",
      namedImports: ["z"],
    });

    sourceFile.addImportDeclaration({
      moduleSpecifier: "@/lib/zodiac",
      namedImports: ["field"],
    });

    // Add schema description comment
    if (config.description) {
      sourceFile.addStatements(`/**
 * ${config.description}
 * Generated by zodiac CLI
 */`);
    }

    // Generate schema object
    const schemaFields = config.fields
      .map((field) => this.generateFieldCode(field))
      .join(",\n  ");

    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: true,
      declarations: [
        {
          name: `${config.name}Schema`,
          initializer: `z.object({\n  ${schemaFields}\n})`,
        },
      ],
    });

    // Generate TypeScript type
    sourceFile.addTypeAlias({
      isExported: true,
      name: `${config.name}Data`,
      type: `z.infer<typeof ${config.name}Schema>`,
    });

    // Format the generated code
    const rawCode = sourceFile.getFullText();
    const formattedCode = await this.formatCode(rawCode);
    sourceFile.replaceWithText(formattedCode);

    await sourceFile.save();
    logger.success(`âœ… Schema generated: ${outputPath}`);
  }

  /**
   * Add a field to an existing schema
   */
  async addFieldToSchema(
    schemaFile: string,
    field: FieldConfig
  ): Promise<void> {
    logger.info(`ðŸ”§ Adding field '${field.name}' to ${schemaFile}`);

    if (!existsSync(schemaFile)) {
      throw new Error(`Schema file not found: ${schemaFile}`);
    }

    const sourceFile = this.project.addSourceFileAtPath(schemaFile);

    // Find the schema object
    const schemaVar = sourceFile
      .getVariableDeclarations()
      .find((decl) => decl.getName().endsWith("Schema"));

    if (!schemaVar) {
      throw new Error("Could not find schema variable in file");
    }

    const initializer = schemaVar.getInitializer();
    if (!initializer) {
      throw new Error("Schema variable has no initializer");
    }

    // Get the current schema text and add the new field
    const currentText = initializer.getText();
    const fieldCode = this.generateFieldCode(field);

    // Better regex to handle the z.object structure
    let newText: string;
    if (currentText.includes("z.object({") && currentText.includes("})")) {
      // Check if schema is empty
      const isEmpty = /z\.object\(\{\s*\}\)/.test(currentText);
      if (isEmpty) {
        newText = currentText.replace(
          /z\.object\(\{\s*\}\)/,
          `z.object({\n  ${fieldCode}\n})`
        );
      } else {
        // Add to existing fields - look for the last field and add after it
        // Match the pattern: last field content, possible comma, whitespace, then })
        newText = currentText.replace(/(,?\s*)\}\)$/, `,\n  ${fieldCode}$1})`);
      }
    } else {
      throw new Error("Could not parse schema object structure");
    }

    schemaVar.setInitializer(newText);

    // Format the updated code
    const rawCode = sourceFile.getFullText();
    const formattedCode = await this.formatCode(rawCode);
    sourceFile.replaceWithText(formattedCode);

    await sourceFile.save();
    logger.success(`âœ… Field '${field.name}' added to schema`);
  }

  /**
   * Generate form component using the schema
   */
  async generateFormComponent(
    schemaName: string,
    outputPath: string
  ): Promise<void> {
    logger.info(`ðŸ”§ Generating form component for ${schemaName}`);

    const dir = dirname(outputPath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    const sourceFile = this.project.createSourceFile(outputPath, "", {
      overwrite: true,
    });

    // Add imports with proper aliases
    sourceFile.addImportDeclaration({
      moduleSpecifier: "react",
      namedImports: ["useState"],
    });

    sourceFile.addImportDeclaration({
      moduleSpecifier: "react-hook-form",
      namedImports: ["useForm"],
    });

    sourceFile.addImportDeclaration({
      moduleSpecifier: "@hookform/resolvers/zod",
      namedImports: ["zodResolver"],
    });

    sourceFile.addImportDeclaration({
      moduleSpecifier: "@/schemas",
      namedImports: [`${schemaName}Schema`, `${schemaName}Data`],
    });

    // Generate component code
    const componentCode = `
export function ${schemaName}Form() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<${schemaName}Data>({
    resolver: zodResolver(${schemaName}Schema),
  });

  const onSubmit = async (data: ${schemaName}Data) => {
    console.log("Form submitted:", data);
    // Handle form submission here
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <h2 className="text-xl font-bold">${schemaName} Form</h2>
      
      {/* Form fields will be generated here */}
      <div className="text-sm text-gray-500">
        Form generated by zodiac CLI - customize as needed
      </div>
      
      <button
        type="submit"
        disabled={isSubmitting}
        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
      >
        {isSubmitting ? "Submitting..." : "Submit"}
      </button>
    </form>
  );
}`;

    sourceFile.addStatements(componentCode);

    // Format the generated code
    const rawCode = sourceFile.getFullText();
    const formattedCode = await this.formatCode(rawCode);
    sourceFile.replaceWithText(formattedCode);

    await sourceFile.save();
    logger.success(`âœ… Form component generated: ${outputPath}`);
  }

  /**
   * Generate field code for a schema
   */
  private generateFieldCode(field: FieldConfig): string {
    // Use the browser-compatible function
    return generateFieldCode({
      name: field.name,
      type: field.type,
      validation: field.validation,
      optional: field.optional,
    });
  }
}
