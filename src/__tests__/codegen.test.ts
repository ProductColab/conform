import { describe, it, expect, beforeEach, vi, afterEach } from "vitest";
import {
  existsSync,
  mkdirSync,
  writeFileSync,
  readFileSync,
  rmSync,
} from "node:fs";
import { join } from "node:path";
import { CodeGenerator } from "../cli/utils/codegen";
import type { FieldConfig, SchemaConfig } from "../cli/utils/codegen";

describe("CodeGenerator", () => {
  let generator: CodeGenerator;
  const testDir = "test-output";

  beforeEach(() => {
    // Mock console methods to avoid noise
    vi.spyOn(console, "log").mockImplementation(() => {});
    vi.spyOn(console, "error").mockImplementation(() => {});

    generator = new CodeGenerator();

    // Clean up test directory
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
    mkdirSync(testDir, { recursive: true });
  });

  afterEach(() => {
    vi.restoreAllMocks();

    // Clean up after tests
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
  });

  describe("generateSchema", () => {
    it("should generate a basic schema with single field", async () => {
      const config: SchemaConfig = {
        name: "User",
        fields: [{ name: "email", type: "string", validation: ["email"] }],
      };

      const outputPath = join(testDir, "user.ts");
      await generator.generateSchema(config, outputPath);

      expect(existsSync(outputPath)).toBe(true);
      const content = readFileSync(outputPath, "utf-8");

      expect(content).toContain('import { z } from "zod"');
      expect(content).toContain('import { field } from "@/lib/conform"');
      expect(content).toContain("export const UserSchema = z.object({");
      expect(content).toContain("email: field.email()");
      expect(content).toContain(
        "export type UserData = z.infer<typeof UserSchema>"
      );
      expect(content).not.toContain("UserDefaults");
    });

    it("should generate schema with multiple fields", async () => {
      const config: SchemaConfig = {
        name: "Contact",
        fields: [
          { name: "name", type: "string" },
          { name: "age", type: "number" },
          { name: "active", type: "boolean" },
          {
            name: "email",
            type: "string",
            validation: ["email"],
            optional: true,
          },
        ],
      };

      const outputPath = join(testDir, "contact.ts");
      await generator.generateSchema(config, outputPath);

      const content = readFileSync(outputPath, "utf-8");

      expect(content).toContain("name: field.text()");
      expect(content).toContain("age: field.number()");
      expect(content).toContain("active: field.boolean()");
      expect(content).toContain("email: field.email().optional()");

      expect(content).not.toContain("ContactDefaults");
    });

    it("should generate schema with description", async () => {
      const config: SchemaConfig = {
        name: "User",
        description: "User registration schema",
        fields: [{ name: "email", type: "string" }],
      };

      const outputPath = join(testDir, "user.ts");
      await generator.generateSchema(config, outputPath);

      const content = readFileSync(outputPath, "utf-8");
      expect(content).toContain("/**");
      expect(content).toContain("User registration schema");
      expect(content).toContain("Generated by Conform CLI");
    });

    it("should handle empty schema", async () => {
      const config: SchemaConfig = {
        name: "Empty",
        fields: [],
      };

      const outputPath = join(testDir, "empty.ts");
      await generator.generateSchema(config, outputPath);

      const content = readFileSync(outputPath, "utf-8");
      expect(content).toContain("export const EmptySchema = z.object({");
      expect(content).not.toContain("EmptyDefaults");
    });

    it("should create output directory if it doesn't exist", async () => {
      const config: SchemaConfig = {
        name: "Test",
        fields: [{ name: "value", type: "string" }],
      };

      const deepPath = join(testDir, "nested", "deep", "test.ts");
      await generator.generateSchema(config, deepPath);

      expect(existsSync(deepPath)).toBe(true);
    });
  });

  describe("addFieldToSchema", () => {
    beforeEach(async () => {
      // Create a test schema file first (without defaults)
      const initialSchema = `import { z } from "zod";
import { field } from "@/lib/conform";

export const UserSchema = z.object({
  name: field.text(),
});

export type UserData = z.infer<typeof UserSchema>;`;

      const schemaPath = join(testDir, "user.ts");
      writeFileSync(schemaPath, initialSchema);
    });

    it("should add field to existing schema", async () => {
      const schemaPath = join(testDir, "user.ts");
      const field: FieldConfig = {
        name: "email",
        type: "string",
        validation: ["email"],
      };

      await generator.addFieldToSchema(schemaPath, field);

      const content = readFileSync(schemaPath, "utf-8");
      expect(content).toContain("name: field.text()");
      expect(content).toContain("email: field.email()");
    });

    it("should add optional field correctly", async () => {
      const schemaPath = join(testDir, "user.ts");
      const field: FieldConfig = {
        name: "phone",
        type: "string",
        optional: true,
      };

      await generator.addFieldToSchema(schemaPath, field);

      const content = readFileSync(schemaPath, "utf-8");
      expect(content).toContain("phone: field.text().optional()");
    });

    it("should handle different field types", async () => {
      const schemaPath = join(testDir, "user.ts");

      const fields: FieldConfig[] = [
        { name: "age", type: "number" },
        { name: "active", type: "boolean" },
        { name: "birthDate", type: "date" },
      ];

      for (const field of fields) {
        await generator.addFieldToSchema(schemaPath, field);
      }

      const content = readFileSync(schemaPath, "utf-8");
      expect(content).toContain("age: field.number()");
      expect(content).toContain("active: field.boolean()");
      expect(content).toContain("birthDate: field.date()");
    });

    it("should handle adding field to empty schema", async () => {
      // Create empty schema (without defaults)
      const emptySchema = `import { z } from "zod";
import { field } from "@/lib/conform";

export const EmptySchema = z.object({});

export type EmptyData = z.infer<typeof EmptySchema>;`;

      const schemaPath = join(testDir, "empty.ts");
      writeFileSync(schemaPath, emptySchema);

      const field: FieldConfig = {
        name: "first",
        type: "string",
      };

      await generator.addFieldToSchema(schemaPath, field);

      const content = readFileSync(schemaPath, "utf-8");
      expect(content).toContain("first: field.text()");
    });

    it("should throw error for non-existent file", async () => {
      const field: FieldConfig = { name: "test", type: "string" };

      await expect(
        generator.addFieldToSchema("non-existent.ts", field)
      ).rejects.toThrow("Schema file not found");
    });

    it("should throw error for invalid schema structure", async () => {
      const invalidSchema = `const invalid = "not a schema";`;
      const schemaPath = join(testDir, "invalid.ts");
      writeFileSync(schemaPath, invalidSchema);

      const field: FieldConfig = { name: "test", type: "string" };

      await expect(
        generator.addFieldToSchema(schemaPath, field)
      ).rejects.toThrow("Could not find schema variable");
    });
  });

  describe("generateFormComponent", () => {
    it("should generate basic form component", async () => {
      const outputPath = join(testDir, "UserForm.tsx");
      await generator.generateFormComponent("User", outputPath);

      expect(existsSync(outputPath)).toBe(true);
      const content = readFileSync(outputPath, "utf-8");

      expect(content).toContain('import { useState } from "react"');
      expect(content).toContain('import { useForm } from "react-hook-form"');
      expect(content).toContain(
        'import { zodResolver } from "@hookform/resolvers/zod"'
      );
      expect(content).toContain(
        'import { UserSchema, UserData } from "@/schemas"'
      );
      expect(content).toContain("export function UserForm()");
      expect(content).toContain("useForm<UserData>");
      expect(content).toContain("resolver: zodResolver(UserSchema)");
      expect(content).not.toContain("defaultValues");
    });

    it("should create output directory for form component", async () => {
      const deepPath = join(testDir, "components", "forms", "UserForm.tsx");
      await generator.generateFormComponent("User", deepPath);

      expect(existsSync(deepPath)).toBe(true);
    });

    it("should handle different schema names", async () => {
      const names = ["Contact", "Registration", "Settings"];

      for (const name of names) {
        const outputPath = join(testDir, `${name}Form.tsx`);
        await generator.generateFormComponent(name, outputPath);

        const content = readFileSync(outputPath, "utf-8");
        expect(content).toContain(`export function ${name}Form()`);
        expect(content).toContain(`${name}Schema`);
        expect(content).toContain(`${name}Data`);
      }
    });
  });

  describe("field generation edge cases", () => {
    it("should handle field with validation rules", () => {
      // Test the internal generateFieldCode method through schema generation
      const config: SchemaConfig = {
        name: "Test",
        fields: [
          {
            name: "password",
            type: "string",
            validation: ["min:8", "max:50"],
          },
        ],
      };

      // This tests the private generateFieldCode method indirectly
      expect(config.fields[0].validation).toContain("min:8");
      expect(config.fields[0].validation).toContain("max:50");
    });

    it("should handle array and object types", async () => {
      const config: SchemaConfig = {
        name: "Complex",
        fields: [
          { name: "tags", type: "array" },
          { name: "metadata", type: "object" },
        ],
      };

      const outputPath = join(testDir, "complex.ts");
      await generator.generateSchema(config, outputPath);

      const content = readFileSync(outputPath, "utf-8");
      expect(content).toContain("tags: z.array(z.string())");
      expect(content).toContain("metadata: z.object({})");
    });

    it("should handle optional fields", async () => {
      const config: SchemaConfig = {
        name: "OptionalTest",
        fields: [
          { name: "required", type: "string" },
          { name: "optional", type: "string", optional: true },
        ],
      };

      const outputPath = join(testDir, "optional.ts");
      await generator.generateSchema(config, outputPath);

      const content = readFileSync(outputPath, "utf-8");
      expect(content).toContain("required: field.text()");
      expect(content).toContain("optional: field.text().optional()");
    });
  });

  describe("formatting", () => {
    it("should format generated code with prettier", async () => {
      const config: SchemaConfig = {
        name: "Test",
        fields: [{ name: "value", type: "string" }],
      };

      const outputPath = join(testDir, "test.ts");
      await generator.generateSchema(config, outputPath);

      const content = readFileSync(outputPath, "utf-8");

      // Check for proper formatting (2 spaces, consistent style)
      expect(content).toMatch(/^import { z } from "zod";$/m);
      expect(content).toMatch(/^import { field } from "@\/lib\/conform";$/m);
      expect(content).not.toContain("              "); // No weird indentation
    });
  });
});
